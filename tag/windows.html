<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" type="text/css" href="/theme/css/style.css"> 
    <link rel="stylesheet" type="text/css" href="/theme/css/pygments.css">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:800,400,300|Inconsolata' rel='stylesheet' type='text/css'>
    <link href="/" type="application/atom+xml" rel="alternate" title="SmileHacker ATOM Feed" />
    
            <title>SmileHacker - windows</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>

<body>
    <section id="navbar">
        <div class="user_meta">
            <h1 id="user"><a href="" class="">SmileHacker</a></h1>
            <h2></h2>
        </div>
        <div class="nav-button">
            <ul>
                                                                                                                                        <li><a href="http://weibo.com/zhouquanbest">Weibo</a></li>
                                                <li><a href="../category/write.html">Write</a></li>
                                                <li><a href="../category/code.html">Code</a></li>
                                                <li><a href="../category/tech.html">Tech</a></li>
                                 </ul>
         </div>
     </section>

     <section id="sidebar">
        <div class="user_meta">
            <h1 id="user"><a href="" class="">SmileHacker</a></h1>
            <h2></h2>
            <ul>
                                                                                                                <li><a href="http://weibo.com/zhouquanbest">Weibo</a></li>
                                        <li><a href="../category/write.html">Write</a></li>
                                        <li><a href="../category/code.html">Code</a></li>
                                        <li><a href="../category/tech.html">Tech</a></li>
                            </ul>
        </div>
        <footer>
            <address>
                Powered by <a href='http://docs.getpelican.com/en/latest/'>Pelican</a>,
                <a href='https://github.com/jamescooke/pelican-svbtle#readme'>theme info</a>.
            </address>
        </footer>
    </section>

    <section id="posts">
                    <article class='listed'>
            <h1 class="title">
                <a href="/win32bian-cheng-ru-men.html" rel='bookmark'>WIN32编程入门</a>
            </h1>
            <div class="article-content"> <hr />
<p>最近学校工程实训，非要我们用MFC编程，没办法，入门研究了一晚上的win32编程。</p>
<p _="%" _Windows_="[Windows]" _lang:="[lang:" c_="c++]%" codeblock="codeblock">学习各种东西，总是开头比较麻烦，自己总结了下win32编程的简单流程，直接上代码了。
<!-- more --></p>
<h1>include</h1>
<h1>include</h1>
<p>// 窗口过程函数
LRESULT CALLBACK WinSunProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);</p>
<p>int WINAPI WinMain(
HINSTANCE hInstance, // handle to current instance
HINSTANCE hPrevInstance, // handle to previous instance
LPSTR lpCmdLine, // command line
int nCmdShow // show state
)</p>
<p>{
// 窗口类
WNDCLASS wndcls;
wndcls.cbClsExtra = 0; // 类附加内存
wndcls.cbWndExtra = 0; // 窗口附加内存
wndcls.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH); // 背景画刷句柄
wndcls.hCursor = LoadCursor(NULL, IDC_CROSS); // 窗口光标句柄
wndcls.hIcon = LoadIcon(NULL, IDI_ERROR); // 窗口图标句柄
wndcls.hInstance = hInstance; // 包含窗口过程函数的程序实例
wndcls.lpfnWndProc = WinSunProc; // 只想窗口过程函数的指针
wndcls.lpszClassName = "Kleist"; // 窗口类名称
wndcls.lpszMenuName = NULL; // 菜单资源
wndcls.style = CS_HREDRAW | CS_VREDRAW; // 窗口样式
RegisterClass(&amp;wndcls);</p>
<p>// 创建窗口， 定义一个变量用来保存成功创建窗口后返回的句柄
HWND hwnd;
hwnd = CreateWindow( // 窗口创建成功时返回为窗口分配的句柄 失败时返回NULL
"Kleist", // 窗口类名
"Hello World", // 窗口名字
WS_OVERLAPPEDWINDOW, // 窗口样式
0, 0, // 窗口左上角坐标
600, 400, // 窗口宽高
NULL, // 父窗口句柄
NULL, // 窗口菜单句柄
hInstance, // 窗口所属应用程序实例
NULL // WM_CREATE消息附加参数lParam传入的数据指针
);</p>
<p>// 显示及刷新窗口
ShowWindow(hwnd, SW_SHOWNORMAL);
UpdateWindow(hwnd);</p>
<p>// 定义消息结构体
MSG msg;
while (GetMessage( // WM_QUIT消息返回0 错误返回-1
&amp;msg, // 指向消息的结构体
NULL, // 指定接收属于哪一窗口的消息 通常设为NULL，用来接收属于调用线程的所有窗口的窗口消息
0, // 获取消息的最小值 通常为0
0)) // 获取消息的最大值 都设为0表示接收所有消息
{
TranslateMessage(&amp;msg); // 将虚拟消息转换为字符消息 投递到调用线程的消息队列中 下次调用GetMessage时被取出
DispatchMessage(&amp;msg); // 将消息传递给操作系统 由操作系统调用窗口过程函数对消息进行处理
}
return msg.wParam;
}</p>
<p>// 窗口过程函数
LRESULT CALLBACK WinSunProc(
HWND hwnd, // 窗口句柄
UINT uMsg, // 消息代码
WPARAM wParam, // 附加参数
LPARAM lParam
)
{
switch(uMsg)
{
case WM_CHAR:
char szChar[20];
sprintf(szChar, "char code is %d", wParam);
MessageBox(hwnd, szChar, "char", 0);
break;</p>
<p>default:
return DefWindowProc(hwnd, uMsg, wParam, lParam);
}</p>
<p _="%" endcodeblock="endcodeblock">return 0;
}</p>
<p>具体也就是WinMain函数作为程序入口，相当于main函数</p>
<p>然后定义窗口类 绑定过程函数，创建窗口实例，显示并刷新窗口实例，建立消息队列。
对着代码看一些参考资料应该就够了。</p> </div>
            <div class="abbr published">Posted <a href='/win32bian-cheng-ru-men.html' title='2013-02-07T21:01:55'>四 07 二月 2013</a></div>
        </article>
        <p class="paginator">
		</p>
    </section>

    </body>
</html>