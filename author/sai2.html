<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" type="text/css" href="http://smilehacker.com/theme/css/style.css"> 
    <link rel="stylesheet" type="text/css" href="http://smilehacker.com/theme/css/pygments.css">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:800,400,300|Inconsolata' rel='stylesheet' type='text/css'>
    <link href="http://smilehacker.com/" type="application/atom+xml" rel="alternate" title="SmileHacker ATOM Feed" />
    
            <title>SmileHacker - Articles by Sai</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>

<body>
    <section id="navbar">
        <div class="user_meta">
            <h1 id="user"><a href="http://smilehacker.com" class="">SmileHacker</a></h1>
            <h2></h2>
        </div>
        <div class="nav-button">
            <ul>
                                                                                                                                        <li><a href="http://weibo.com/zhouquanbest">Weibo</a></li>
                                                <li><a href="http://hustunique.com">Unique Studio</a></li>
                                 </ul>
         </div>
     </section>

     <section id="sidebar">
        <div class="user_meta">
            <h1 id="user"><a href="http://smilehacker.com" class="">SmileHacker</a></h1>
            <h2></h2>
            <ul>
                                                                                                                <li><a href="http://weibo.com/zhouquanbest">Weibo</a></li>
                                        <li><a href="http://hustunique.com">Unique Studio</a></li>
                            </ul>
        </div>
        <footer>
            <address>
                Powered by <a href='http://docs.getpelican.com/en/latest/'>Pelican</a>,
                <a href='https://github.com/jamescooke/pelican-svbtle#readme'>theme info</a>.
            </address>
        </footer>
    </section>

    <section id="posts">
                    <article class='listed'>
            <h1 class="title">
                <a href="http://smilehacker.com/peng-you-su-sheng-jiu.html" rel='bookmark'>朋友 • 俗生 • 酒</a>
            </h1>
            <div class="article-content"> <hr />
<p><span style="color: #ffcc99;">这算是我大学或者说人生第一次真正喝酒吧，当时喝多了还写了些东西，也转过来吧：</span></p>
<p>刚刚喝了很多酒，也算是人生中第一次喝酒。晕乎乎的，飙车回来，很想写点什么。关于朋友，关于酒。</p>
<p>所谓朋友，酒一喝，肩一搭，畅怀大笑，也就成了。</p>
<p>在此之前，个人认为酒有害无益，不知有何存在价值；喝过之后，闹过之后，还是觉得他百害而无益处。但是，就是这毒物，确实人身必不可少的催化剂。</p>
<p>所谓朋友，就是能同甘共苦，坦胸相对。而这酒正是苦痛，与朋交杯，便是苦痛的分担了。</p>
<p>知己者，可以共语；同友者，可以同苦同乐。顶着浓重的眩晕之苦，血管的膨胀之痛，与朋举杯，正是弃开自我，敢于承担的誓言；酒后乱语，欣然长笑，更是摒除世俗，乐于分享的豪气。为此者，何不为朋。</p>
<p>朋友之后，便是俗世。</p>
<p>纵使立志放浪不羁，超脱形骸，也无法拜托“俗”之绊。也许，这是我以不再年轻的哀嚎。</p>
<p>酒前，晓龙学长说了很多，什么敬酒的礼仪，喝酒的重要性。也许过去，我会愤然斥之，但今天，我接受了。也许这便是人生逃不开的惑。</p>
<p>总有很多东西是为世俗鄙视，但又为世俗需求的。昨日象牙塔中的风发意气，今朝可能就变为惨淡的回忆，成长，正在收取它的代价，而我，也沦为世俗中人。</p>
<p>四瓶下肚，人是难受的，但却是高兴的。也许是因为结交了酒后朋友，也许是因为感怀的人身炎凉。</p>
<p>也许只是酒后疯语，梦醒之后，再观世道</p> </div>
            <div class="abbr published">Posted <a href='http://smilehacker.com/peng-you-su-sheng-jiu.html' title='2013-02-07T21:10:31'>四 07 二月 2013</a></div>
        </article>
            <article class='listed'>
            <h1 class="title">
                <a href="http://smilehacker.com/qi-yuan.html" rel='bookmark'>起源</a>
            </h1>
            <div class="article-content"> <hr />
<p><strong>引子——</strong></p>
<p>&nbsp;</p>
<p>你是谁？</p>
<p>你从何而来？</p>
<p>你要到哪去？</p>
<p>&nbsp;</p>
<p>这不是哲学家的问题，这是我们每个人的问题。</p>
<p>当你思考自己的起源时，都会陷入无限的循环与苦楚之中。</p>
<p>&nbsp;</p>
<p>我来自哪里，我为何而来，谁创造了我？</p>
<p>如果是上帝，那谁又是上帝，上帝又从何而来？</p>
<p>如果是宇宙大爆炸的尘埃，那宇宙又从何而来，宇宙外面是什么，外面的外面又是什么？</p>
<p>&nbsp;</p>
<p>或者说上帝是永恒的，宇宙是无限的，那永恒与无限又是什么，这不是一个合理的解释</p>
<p>至少我无法接受。</p>
<p>&nbsp;</p>
<p>这个问题让我那难以入眠，每当想起，都焦躁不安</p>
<p>世界就像魔术师手里的兔子，诞生于诡异的帽子魔法</p>
<p>我们就诞生于兔子的毛发上，想努力攀爬到顶端去看看魔法师的样子，想看清这不解的魔法。</p>
<p>&nbsp;</p>
<p>但我们失败了，年长时，我们接受的“现实”，接受了“真理”</p>
<p>于是世界变成了：本来就是这样</p>
<p>我们遗弃了本源，在自己的秩序里生存，在终焉里安眠。</p>
<p>&nbsp;</p>
<p>但还有一群人不接受这样的现实，他们保留了那原始的疑惑</p>
<p>他们在探寻着自己的起源</p>
<p>他们在宗教、科学、魔法、哲学中挣扎</p>
<p>我称他们为开辟的使者</p>
<p>&nbsp;</p>
<p>而我，则默默的记录着这一切。</p>
<p>&nbsp;</p>
<p>&nbsp;
<!-- more -->
<strong>疑惑——</strong></p>
<p>&nbsp;</p>
<p>起源的问题，已经在人类浩瀚的历史里被探讨了多次，但没有人得出了结果，没有人能够用双眼去见证它，他的一切都被“混乱”所掩盖。</p>
<p>试着跟着我做，闭上眼，在大脑中构建一个宇宙，我们的星云置身其中，我们的星球在银河系里，而我们也只是星球上不起眼的一点，然后将视野放大，放到宇宙的边缘，然后是宇宙之外。</p>
<p>如果宇宙是有空间大小的，那他的外面一定还有东西，是另一个宇宙，父级宇宙的外面呢，如果他也有大小，那外面一定还有。继续放到，将思维无限放大，去试着包容这一切，让大脑去解析所有的宇宙。</p>
<p>于是混乱开始了，这没有终点，当你记录了一定数量的宇宙后，你开始焦躁，开始迷惑，开始无法冷静，手心出汗，双腿颤抖，你的内存已经泄漏，栈溢出是必然的结果。</p>
<p>&nbsp;</p>
<p>好， 我们换个假设，如果宇宙之外不是无限的，我们定义我们能理解的宇宙为“有”，那么我们不能理解的必定为“无”了。我们生活在“有”里，有的外面是“无”。 好的，悖论出来了，“无”在“有”之外，即“有”之外还有东西，因为“有”的定义是有范围的，而范围又是需要名为“无”的“有”来确立。我们无法定义 “无”。</p>
<p>&nbsp;</p>
<p>那么世界是起源于“无”吗？</p>
<p>无数的物质世界在大爆炸里从“无”诞生。</p>
<p>&nbsp;</p>
<p>科学家为了定义这个世界曾经作出如下假设：</p>
<p>能量 == 物质 + 反物质</p>
<p>&nbsp;</p>
<p>认为宇宙中还有一些称为“反物质”的粒子，当他们与物质想碰时，便会与之一同湮灭，产生能量。至今反质子、反中子还没被找到。</p>
<p>如果假设成立，那么我们便需否决“无”，或者“无”就是能量。</p>
<p>&nbsp;</p>
<p>====</p>
<p>有限或无限，无或者有都无法让我解释这个世界，以及这个世界以外的世界。</p>
<p>当我去竭力思考时便会陷入一种“混乱”，让我无法继续，如果继续下去，我想我的大脑会因无法接受这海量的数据而变得疯狂。</p>
<p>&nbsp;</p>
<p>于是我开始从已有的“猜想”中开始寻求解脱。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>体系神话——</strong></p>
<p>&nbsp;</p>
<p>当人类无法理解某些因果时，就会用一些荒唐的故事来神化它们</p>
<p>比如闪电，天空最强大的自然现象，每一次劈开天空，都震撼人心</p>
<p>于是他被赋予给最强大的幻想，宙斯、佐尔，这些最强大的神明才有驾驭它的能力。</p>
<p>&nbsp;</p>
<p>现代，也有无数学者在遇到无法解决的问题时开始了幻想之路，比如克苏恩神话。他给我带来了很多不错的思路，结合人类历史上的种种创奇，我总结了自己的神话体系。</p>
<p>&nbsp;</p>
<p><strong>混沌的开始——</strong></p>
<p>&nbsp;</p>
<p>世界依旧起源于无，一片空虚，一片寂静</p>
<p>&nbsp;</p>
<p>但这是矛盾的，这矛盾在世界里膨胀，不知从何时起，不知在哪个维度出现</p>
<p>只知道那是自世界诞生，或者说世界有了该存在的意识起</p>
<p>在每一个角落，或者就是整个空间里</p>
<p>都开始争吵</p>
<p>&nbsp;</p>
<p>矛盾越来越来</p>
<p>越来越大</p>
<p>&nbsp;</p>
<p>“轰”</p>
<p>寂灭中出现一声翻天覆地的“巨响”</p>
<p>&nbsp;</p>
<p>宇宙产生了。</p>
<p>&nbsp;</p>
<p>宇宙产生自这无法解决的矛盾</p>
<p>因为这矛盾宇宙产生</p>
<p>&nbsp;</p>
<p>宇宙就是悖论 宇宙源于悖论 宇宙带来悖论</p>
<p><strong>
</strong></p>
<p><strong>混乱与秩序——</strong></p>
<p>&nbsp;</p>
<p>想想我们自己，我们是什么</p>
<p>是一堆有机物的组合，是肉体与灵魂的交杂，是物质世界的随机因果？</p>
<p>&nbsp;</p>
<p>不，我们是矛盾，是混乱与秩序的矛盾。</p>
<p>看看我们自己，拥有理性，却也具有感性</p>
<p>我们可以像机器一样生存，遵循没一个因果，在没一个公式下的推导下按照理性的逻辑进行“必然”的下一步;</p>
<p>我们也可以像梦境一样或在幻想里，把激素与神经的共同作用称为爱情，把复杂的反射机制归为愤怒、悲伤和高兴，在感性里迎接未知的未来。</p>
<p><strong>
</strong></p>
<p>我们把理性称之为“秩序”，把感性称之为“混乱”</p>
<p>而我们无数次亲身体会到了两者的碰撞，无数次艰难的在两者间选择</p>
<p>谁是谁非，总是来自于“真理”——那合理的偏见</p>
<p>&nbsp;</p>
<p>微小的我们是矛盾体，世界也是矛盾体。</p>
<p>&nbsp;</p>
<p><strong>神——</strong></p>
<p>&nbsp;</p>
<p>世界爆炸了，诞生了宇宙，也诞生了两个认知意外的“物质”</p>
<p>秩序与混沌</p>
<p>&nbsp;</p>
<p>他们分属矛盾的两边，是世界无法承受他们时通过大爆炸释放的。</p>
<p>大爆炸后他们交错在一起，却互相排斥，挤压</p>
<p>于是宇宙越来越大，温度越来越高</p>
<p>&nbsp;</p>
<p>高温让他们的结构变得不稳定，他们开始分裂，变成无数粒子，散落在宇宙里</p>
<p>慢慢的，他们的意识开始消亡，宇宙开始冷却</p>
<p>&nbsp;</p>
<p>冷却中无数秩序粒子组合在一起，形成了宇宙里的尘埃</p>
<p>混乱也开始汇聚，但混乱的特性让他们无形</p>
<p>&nbsp;</p>
<p>秩序更为稳定，他们在无数随机或者说“必然”下，重新获得了意识</p>
<p>成为无机的神——泰坦</p>
<p>无情、强大、神秘、中里的东西</p>
<p>&nbsp;</p>
<p>他们诞生目的只有一个，修复宇宙，让世界重新获得秩序，归于无。</p>
<p>&nbsp;</p>
<p>混乱也开始冷却，附着于没有意识的尘埃上，开始展现自己的生命意识。</p>
<p>他们被称之为“古神”，混乱的结合体</p>
<p>他们没有形体，他们唯一的意识就是吞噬</p>
<p>就像癌细胞，他们在宇宙里肆虐，吞噬遇到的一切，包括泰坦。</p>
<p>&nbsp;</p>
<p>显然泰坦们力量更为强大，遵循秩序让他们更适合在物质世界生存。</p>
<p>他们组成了议会，他们开始合作，开始操纵尘埃，将他们做成武器，开始毁灭古神。</p>
<p>&nbsp;</p>
<p>但是和他们一样，古神起源于矛盾，“混乱”是无法消除的“存在”</p>
<p>所以泰坦只好将古神封印，用更多的物质建立监牢，让古神沉睡于中。</p>
<p>&nbsp;</p>
<p>而这监牢，就如同我们可以理解的尘埃汇集物——星球。</p>
<p>&nbsp;</p>
<p><strong>苏醒——</strong></p>
<p>&nbsp;</p>
<p>古神们陷入了深眠，但也有例外。</p>
<p>在一颗星球上，一个古神开始苏醒，他发现监牢在周边星球的引力下出现了裂口。</p>
<p>他开始伸展自己的思维，用混乱去影响周遭。</p>
<p>特别是泰坦留下的无机守卫。</p>
<p>&nbsp;</p>
<p>古神的神格就像海洋包围者这些由颗粒构成的守卫，就像在电场下光速震颤的电子，开始变得不稳定。</p>
<p>守卫的结构被打乱，粒子们不断汇聚与散开，不断重组又不断被撕裂。</p>
<p>&nbsp;</p>
<p>最后，守卫们被打败了，变成了古神的奴仆——“上古之神”</p>
<p>在这颗星球上一共诞生了四位上古之神</p>
<p>上古之神由于源自被吞噬的守卫，他们在物质世界有了形体。</p>
<p>上古之神不断的吞噬物质并且开始疯狂的生长，但缺失秩序的他们只能像肉团一样，不断的生出触须，粘液</p>
<p>&nbsp;</p>
<p><strong>战乱——</strong></p>
<p>&nbsp;</p>
<p>泰坦发现了古神的异动，降临到这可星球，开始整顿并毁灭这的一切。</p>
<p>他们在地心遏制着古神，并放出更多的守卫去消灭地表的上古之神。</p>
<p>&nbsp;</p>
<p>显然泰坦低估了上古之神，守卫的力量不足以形成压倒性的优势。</p>
<p>吞噬了守卫的上古之神也开始有了意识，秩序影响了他们的本源</p>
<p>他们的生长改变了星球的环境，甚至使这颗星球出现了大气。</p>
<p>被守卫斩断的肢体在分解后形成了新了生物——有机体。</p>
<p>那些有机体脱离的古神的控制，又结合了守卫的秩序，在两种本源下开始重新组合。</p>
<p>&nbsp;</p>
<p>最终，古神再次被打败了，又一次陷入的长眠。</p>
<p>当泰坦们回到地表时，他们惊愕了</p>
<p>持续几个世纪的战斗后，这颗丑陋贫瘠的星球发生的翻天覆地的变化。</p>
<p>&nbsp;</p>
<p>上古之神被守卫封印到了地底</p>
<p>而地表却出现了不属于两者的生物</p>
<p>他们拥有混乱一样生命，却有秩序一般的外表</p>
<p>&nbsp;</p>
<p>他们的生长遵循这秩序，行为却无法被理解。</p>
<p>泰坦们无法定义他们，不知道是否该给予毁灭。</p>
<p>如果是守卫，他们拥有自己的程式，泰坦可以轻易推导出其行为方式</p>
<p>如果是上古之神，泰坦们无法检测到秩序时只需要给予毁灭</p>
<p>而现在，他们不知所措</p>
<p>&nbsp;</p>
<p>议会最终决定，降临到生物头上的裁决是“观察”</p>
<p>他们留下更佳强大的守卫监视着这些生物</p>
<p>如果其进化为混乱，则立即将其毁灭</p>
<p>&nbsp;</p>
<p>然后，泰坦们离开了。</p>
<p>&nbsp;</p>
<p>==待==</p> </div>
            <div class="abbr published">Posted <a href='http://smilehacker.com/qi-yuan.html' title='2012-11-16T20:07:03'>五 16 十一月 2012</a></div>
        </article>
            <article class='listed'>
            <h1 class="title">
                <a href="http://smilehacker.com/rang-dai-ma-geng-gui-fan-xiong-ya-li-ming-ming-fa.html" rel='bookmark'>让代码更规范——匈牙利命名法</a>
            </h1>
            <div class="article-content"> <hr />
<p>以前用TurboC时，编译器无法动态识别变量类型，东西多了后很蛋疼，你不知道某个变量到底是干嘛的了，特别是维护很久以前的代码。
好的命名规范能给开发和维护带来极大的帮助，基本不需要注释便能让能看懂你的代码，而在所有的命名规范里，我最喜欢的便是匈牙利命名法。</p>
<p>匈牙利命名法是一种编程时的命名规范。基本原则是：</p>
<p><strong>变量名＝属性＋类型＋对象描述</strong></p>
<p>&nbsp;</p>
<p>其中每一对象的名称都要求有明确含义，可以取对象名字全称或名字的一部分。命名要基于容易记忆容易理解的原则。保证名字的连贯性是非常重要的。</p>
<p>&nbsp;</p>
<p>举例来说，表单的名称为form，那么在匈牙利命名法中可以简写为frm，则当表单变量名称为Switchboard时，变量全称应该为 frmSwitchboard。这样可以很容易从变量名看出Switchboard是一个表单，同样，如果此变量类型为标签，那么就应命名成 lblSwitchboard。可以看出，匈牙利命名法非常便于记忆，而且使变量名非常清晰易懂，这样，增强了代码的可读性，方便各程序员之间相互交流代 码。</p>
<p>据说这种命名法是一位叫 Charles Simonyi 的匈牙利程序员发明的，后来他在微软呆了几年，于是这种命名法就通过微软的各种产品和文档资料向世界传播开了。现在，大部分程序员不管自 己使用什么软件进行开发，或多或少都使用了这种命名法。这种命名法的出发点是把变量名按：属性+类型+对象描述的顺序组合起来，以使程序员作变量时对变量 的类型和其它属性有直观的了解，下面是HN变量命名规范，其中也有一些是我个人的偏向：</p>
<!-- more -->

<p><strong>属性部分 </strong></p>
<p><strong>　　全局变量                               g_ </strong></p>
<p><strong>常量                                   c_ </strong></p>
<p><strong>c++</strong><strong>类成员变量                          m_ </strong></p>
<p><strong>　　静态变量                               s_ </strong></p>
<p><strong>　　</strong></p>
<p><strong>类型部分 </strong></p>
<p><strong>　　指针                                   p </strong></p>
<p><strong>　　函数                                   fn </strong></p>
<p><strong>　　无效                                   v </strong></p>
<p><strong>　　句柄                                   h </strong></p>
<p><strong>　　长整型                                 l </strong></p>
<p><strong>　　布尔                                   b </strong></p>
<p><strong>　　浮点型（有时也指文件）                 f </strong></p>
<p><strong>　　双字                                   dw </strong></p>
<p><strong>　　字符串                                 sz </strong></p>
<p><strong>　　短整型                                 n </strong></p>
<p><strong>　　双精度浮点                             d </strong></p>
<p><strong>　　计数                                   c（通常用cnt） </strong></p>
<p><strong>　　字符                                   ch（通常用c） </strong></p>
<p><strong>　　整型                                   i（通常用n） </strong></p>
<p><strong>　　字节                                   by </strong></p>
<p><strong>　　字                                     w </strong></p>
<p><strong>　　实型                                   r </strong></p>
<p><strong>　　无符号                                 u </strong></p>
<p><strong>　　</strong></p>
<p><strong>描述部分 </strong></p>
<p><strong>　　最大                                   Max </strong></p>
<p><strong>　　最小                                   Min </strong></p>
<p><strong>　　初始化                                 Init </strong></p>
<p><strong>　　临时变量                               T（或Temp） </strong></p>
<p><strong>　　源对象                                 Src </strong></p>
<p><strong>　　目的对象                               Dest </strong></p>
<p>这里顺便写几个例子：</p>
<p>hwnd ： h 是类型描述，表示句柄， wnd 是变量对象描述，表示窗口，所以 hwnd 表示窗口句柄；</p>
<p>pfnEatApple ： pfn 是类型描述，表示指向函数的指针， EatApple 是变量对象描述，所以它表示</p>
<p>指向 EatApple 函数的函数指针变量。</p>
<p>g_cch ： g_ 是属性描述，表示全局变量，c 和 ch 分别是计数类型和字符类型，一起表示变量类</p>
<p>型，这里忽略了对象描述，所以它表示一个对字符进行计数的全局变量。</p>
<p>上面就是HN命名法的一般规则。</p>
<p>小结:匈牙利命名法</p>
<p>匈牙利命名法</p>
<p>MFC、句柄、控件及结构的命名规范 Windows类型 样本变量 MFC类 样本变量</p>
<p>HWND hWnd； CWnd* pWnd；</p>
<p>HDLG hDlg； CDialog* pDlg；</p>
<p>HDC hDC； CDC* pDC；</p>
<p>HGDIOBJ hGdiObj； CGdiObject* pGdiObj；</p>
<p>HPEN hPen； CPen* pPen；</p>
<p>HBRUSH hBrush； CBrush* pBrush；</p>
<p>HFONT hFont； CFont* pFont；</p>
<p>HBITMAP hBitmap； CBitmap* pBitmap；</p>
<p>HPALETTE hPaltte； CPalette* pPalette；</p>
<p>HRGN hRgn； CRgn* pRgn；</p>
<p>HMENU hMenu； CMenu* pMenu；</p>
<p>HWND hCtl； CState* pState；</p>
<p>HWND hCtl； CButton* pButton；</p>
<p>HWND hCtl； CEdit* pEdit；</p>
<p>HWND hCtl； CListBox* pListBox；</p>
<p>HWND hCtl； CComboBox* pComboBox；</p>
<p>HWND hCtl； CScrollBar* pScrollBar；</p>
<p>HSZ hszStr； CString pStr；</p>
<p>POINT pt； CPoint pt；</p>
<p>SIZE size； CSize size；</p>
<p>RECT rect； CRect rect；</p>
<p>一般前缀命名规范 前缀 类型 实例</p>
<p>C   类或结构  CDocument ，CPrintInfo</p>
<p>m_  成员变量  m_pDoc，m_nCustomers</p>
<p>变量命名规范</p>
<p>前缀     类型   描述                 实例</p>
<p>ch      char   8位字符              chGrade</p>
<p>ch TCHAR 如果_UNICODE定义，则为16位字符 chName</p>
<p>b BOOL 布尔值 bEnable</p>
<p>n int 整型（其大小依赖于操作系统） nLength</p>
<p>n UINT 无符号值（其大小依赖于操作系统） nHeight</p>
<p>w WORD 16位无符号值 wPos</p>
<p>l LONG 32位有符号整型 lOffset</p>
<p>dw DWORD 32位无符号整型 dwRange</p>
<p>p * 指针 pDoc</p>
<p>lp FAR* 远指针 lpszName</p>
<p>lpsz LPSTR 32位字符串指针 lpszName</p>
<p>lpsz LPCSTR 32位常量字符串指针 lpszName</p>
<p>lpsz LPCTSTR 如果_UNICODE定义，则为32位常量字符串指针 lpszName</p>
<p>h handle Windows对象句柄 hWnd</p>
<p>lpfn callback 指向CALLBACK函数的远指针</p>
<p>前缀 符号类型 实例 范围</p>
<p>IDR_ 不同类型的多个资源共享标识 IDR_MAIINFRAME 1～0x6FFF</p>
<p>IDD_ 对话框资源 IDD_SPELL_CHECK 1～0x6FFF</p>
<p>HIDD_ 对话框资源的Help上下文 HIDD_SPELL_CHECK 0x20001～0x26FF</p>
<p>IDB_ 位图资源 IDB_COMPANY_LOGO 1～0x6FFF</p>
<p>IDC_ 光标资源 IDC_PENCIL 1～0x6FFF</p>
<p>IDI_ 图标资源 IDI_NOTEPAD 1～0x6FFF</p>
<p>ID_ 来自菜单项或工具栏的命令 ID_TOOLS_SPELLING 0x8000～0xDFFF</p>
<p>HID_ 命令Help上下文 HID_TOOLS_SPELLING 0x18000～0x1DFFF</p>
<p>IDP_ 消息框提示 IDP_INVALID_PARTNO 8～0xDEEF</p>
<p>HIDP_ 消息框Help上下文 HIDP_INVALID_PARTNO 0x30008～0x3DEFF</p>
<p>IDS_ 串资源 IDS_COPYRIGHT 1～0x7EEF</p>
<p>IDC_ 对话框内的控件 IDC_RECALC 8～0xDEEF</p>
<p>Microsoft MFC宏命名规范 名称 类型</p>
<p>_AFXDLL 唯一的动态连接库（Dynamic Link Library，DLL）版本</p>
<p>_ALPHA 仅编译DEC Alpha处理器</p>
<p>_DEBUG 包括诊断的调试版本</p>
<p>_MBCS 编译多字节字符集</p>
<p>_UNICODE 在一个应用程序中打开Unicode</p>
<p>AFXAPI MFC提供的函数</p>
<p>CALLBACK 通过指针回调的函数</p>
<p>库标识符命名法 标识符 值和含义</p>
<p>u ANSI（N）或Unicode（U）</p>
<p>d 调试或发行：D = 调试；忽略标识符为发行。</p>
<p>静态库版本命名规范 库 描述</p>
<p>NAFXCWD.LIB 调试版本：MFC静态连接库</p>
<p>NAFXCW.LIB 发行版本：MFC静态连接库</p>
<p>UAFXCWD.LIB 调试版本：具有Unicode支持的MFC静态连接库</p>
<p>UAFXCW.LIB 发行版本：具有Unicode支持的MFC静态连接库</p>
<p>动态连接库命名规范 名称 类型</p>
<p>_AFXDLL 唯一的动态连接库（DLL）版本</p>
<p>WINAPI Windows所提供的函数</p>
<p>Windows.h中新的命名规范 类型 定义描述</p>
<p>WINAPI 使用在API声明中的FAR PASCAL位置，如果正在编写一个具有导出API人口点的DLL，则可以在自己的API中使用该类型</p>
<p>CALLBACK 使用在应用程序回叫例程，如窗口和对话框过程中的FAR PASCAL的位置</p>
<p>LPCSTR 与LPSTR相同，只是LPCSTR用于只读串指针，其定义类似（const char FAR*）</p>
<p>UINT 可移植的无符号整型类型，其大小由主机环境决定（对于Windows NT和Windows 9x为32位）；它是unsigned int的同义词</p>
<p>LRESULT 窗口程序返回值的类型</p>
<p>LPARAM 声明lParam所使用的类型，lParam是窗口程序的第四个参数</p>
<p>WPARAM 声明wParam所使用的类型，wParam是窗口程序的第三个参数</p>
<p>LPVOID 一般指针类型，与（void *）相同，可以用来代替LPSTR</p>
<hr />
<p>抨击匈牙利命名法</p>
<p>匈牙利命名法是一种编程时的命名规范。命名规范是程序书写规范中最重要也是最富争议的地方，自古乃兵家必争之地。命名规范有何用？四个字：名正言顺。用 二分法，命名规范分为好的命名规范和坏的命名规范，也就是说名正言顺的命名规范和名不正言不顺的命名规范。好的舞鞋是让舞者感觉不到其存在的舞鞋，坏的舞 鞋是让舞者带着镣铐起舞。一个坏的命名规范具有的破坏力比一个好的命名规范具有的创造力要大得多。</p>
<p>本文要证明的是：匈牙利命名法是一个坏的命名规范。本文的作用范围为静态强类型编程语言。本文的分析范本为C语言和C++语言。下文中的匈法为匈牙利命名法的简称。</p>
<p>一 匈牙利命名法的成本</p>
<p>匈法的表现形式为给变量名附加上类型名前缀，例如：nFoo,szFoo,pFoo,cpFoo分别表示整型变量，字符串型变量，指针型变量和常指针型 变量。可以看出，匈法将变量的类型信息从单一地点（声明变量处）复制到了多个地点（使用变量处），这是冗余法。冗余法的成本之一是要维护副本的一致性。这 个成本在编写和维护代码的过程中需要改变变量的类型时付出。冗余法的成本之二是占用了额外的空间。一个优秀的书写者会自觉地遵从一个法则：代码最小组织单 位的长度以30个自然行以下为宜，如果超过50行就应该重新组织。一个变量的书写空间会给这一法则添加不必要的难度。</p>
<p>二 匈牙利命名法的收益</p>
<p>这里要证明匈牙利命名法的收益是含糊的，无法预期的。</p>
<p>范本1：strcpy(pstrFoo,pcstrFoo2) Vs strcpy(foo,foo2)</p>
<p>匈法在这里有什么收益呢？我看不到。没有一个程序员会承认自己不知道strcpy函数的参数类型吧。</p>
<p>范本2：unknown_function(nFoo) Vs unknown_function(foo)</p>
<p>匈法在这里有什么收益呢？我看不到。对于一个不知道确定类型的函数，程序员应该去查看该函数的文档，这是一种成本。使用匈法的唯一好处是看代码的人知道 这个函数要求一个整型参数，这又有什么用处呢？函数是一种接口，参数的类型仅仅是接口中的一小部分。诸如函数的功能、出口信息、线程安全性、异常安全性、 参数合法性等重要信息还是必须查阅文档。</p>
<p>范本3：nFoo=nBar Vs foo=bar</p>
<p>匈法在这里有什么收益 呢？我看不到。使用匈法的唯一好处是看代码的人知道这里发生了一个整型变量的复制动作，听起来没什么问题，可以安心睡大觉了。如果他看到的是 nFoo=szBar，可能会从美梦中惊醒。且慢，事情真的会是这样吗？我想首先被惊醒的应该是编译器。另一方面，nFoo=nBar只是在语法上合法而 已，看代码的人真正关心的是语义的合法性，匈法对此毫无帮助。另一方面，一个优秀的书写者会自觉地遵从一个法则：代码最小组织单位中的临时变量以一两个为 宜，如果超过三个就应该重新组织。结合前述第一个法则，可以得出这样的结论：易于理解的代码本身就应该是易于理解的，这是代码的内建高质量。好的命名规范 对内建高质量的助益相当有限，而坏的命名规范对内建高质量的损害比人们想象的要大。</p>
<p>三 匈牙利命名法的实施</p>
<p>这里要证明匈牙利命名法在C语言是难以实施的，在C++语言中是无法实施的。从逻辑上讲，对匈法的收益做出否定的结论以后，再来论证匈法的可行性，是画蛇添足。不过有鉴于小马哥曾让已射杀之敌死灰复燃，我还是再踏上一支脚为妙。</p>
<p>前面讲过，匈法是类型系统的冗余，所以实施匈法的关键是我们是否能够精确地对类型系统进行复制。这取决于类型系统的复杂性。</p>
<p>先来看看C语言：</p>
<p>1.内置类型：int,char,float,double 复制为 n,ch,f,d？好像没有什么问题。不过谁来告诉我void应该怎么表示？</p>
<p>2.组合类型：array,union,enum,struct 复制为 a,u,e,s？好像比较别扭。</p>
<p>这里的难点不是为主类型取名，而是为副类型取名。an表示整型数组？sfoo,sbar表示结构foo，结构bar？ausfoo表示联合结构foo数组？累不累啊。</p>
<p>3.特殊类型：pointer。pointer在理论上应该是组合类型，但是在C语言中可以认为是内置类型，因为C语言并没有非常严格地区分不同的指针类型。下面开始表演：pausfoo表示联合结构foo数组指针？ppp表示指针的指针的指针？</p>
<p>噩梦还没有结束，再来看看类型系统更为丰富的C++语言：</p>
<p>1.class：如果说C语言中的struct还可以用stru搪塞过去的话，不要梦想用cls来搪塞C++中的class。严格地讲，class根本 就并不是一个类型，而是创造类型的工具，在C++中，语言内置类型的数量和class创造的用户自定义类型的数量相比完全可以忽略不计。 stdvectorFoo表示标准库向量类型变量Foo？疯狂的念头。</p>
<p>2.命名空间：boostfilesystemiteratorFoo，表示boost空间filesystem子空间遍历目录类型变量Foo？程序员要崩溃了。</p>
<p>3.模板：你记得std::map&lt;std::string,std::string&gt;类型的确切名字吗？我是记不得了，好像超过255个字符，还是饶了我吧。</p>
<p>4.模板参数：template &lt;class T, class BinaryPredicate&gt;const T&amp; max(const T&amp; a, const T&amp; b, BinaryPredicate comp) 聪明的你，请用匈法为T命名。上帝在发笑。</p>
<p>5.类型修饰：static,extern,mutable,register,volatile,const,short,long,unsigned 噩梦加上修饰是什么？还是噩梦。</p> </div>
            <div class="abbr published">Posted <a href='http://smilehacker.com/rang-dai-ma-geng-gui-fan-xiong-ya-li-ming-ming-fa.html' title='2013-02-07T21:07:22'>四 07 二月 2013</a></div>
        </article>
            <article class='listed'>
            <h1 class="title">
                <a href="http://smilehacker.com/rang-yong-hu-ti-yan-gai-bian-linux.html" rel='bookmark'>让用户体验改变Linux</a>
            </h1>
            <div class="article-content"> <hr />
<p>不到一年前。我还是个Windows死忠，倒不是不喜欢Linux，而是因为Linux当时2.6的内核不支持双显卡，只能放弃。<br />
后来到了3.0内核的时代，终于能进入X了，也体验到了Linux的魅力，深深的为之动容。奈何XWindow是如此的不争气，各种bug与对用户体验的漠视让吾辈在无限的崩溃中抓狂。我甚至专门写了篇文章对比windows与Ubuntu的交互差别，来证明程序猿也是需要关爱的。  </p>
<p>Office、QQ、Thunder、Sogou，这些都是Win的王牌，不过时至今日，随着开源的盛行与互联网的强势崛起，各大公司也开始重新审视Linux。Wiz、WPS等先后登陆，现在Sogou输入法也来了，Chrome上也有了Dualx这样的QQ插件，不用再忍受wineQQ了。  </p>
<p><img alt="sogou" src="http://i5.minus.com/iG7EhXIXYX5q2.png" /></p>
<p>为了替代坑爹的Xwindow，各大社区也开始向Wayland转型，GTK+3.1宣布将在9月与Wayland一同发布，Gnome3.8与Arch均表示将支持之。相信在2014之前，我们能够见到由Wayland支持的强大Linux GUI,Linux桌面端将焕发第二春。</p> </div>
            <div class="abbr published">Posted <a href='http://smilehacker.com/rang-yong-hu-ti-yan-gai-bian-linux.html' title='2013-03-29T10:59:47'>五 29 三月 2013</a></div>
        </article>
            <article class='listed'>
            <h1 class="title">
                <a href="http://smilehacker.com/win32bian-cheng-ru-men.html" rel='bookmark'>WIN32编程入门</a>
            </h1>
            <div class="article-content"> <hr />
<p>最近学校工程实训，非要我们用MFC编程，没办法，入门研究了一晚上的win32编程。</p>
<p _="%" _Windows_="[Windows]" _lang:="[lang:" c_="c++]%" codeblock="codeblock">学习各种东西，总是开头比较麻烦，自己总结了下win32编程的简单流程，直接上代码了。
<!-- more --></p>
<h1>include</h1>
<h1>include</h1>
<p>// 窗口过程函数
LRESULT CALLBACK WinSunProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);</p>
<p>int WINAPI WinMain(
HINSTANCE hInstance, // handle to current instance
HINSTANCE hPrevInstance, // handle to previous instance
LPSTR lpCmdLine, // command line
int nCmdShow // show state
)</p>
<p>{
// 窗口类
WNDCLASS wndcls;
wndcls.cbClsExtra = 0; // 类附加内存
wndcls.cbWndExtra = 0; // 窗口附加内存
wndcls.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH); // 背景画刷句柄
wndcls.hCursor = LoadCursor(NULL, IDC_CROSS); // 窗口光标句柄
wndcls.hIcon = LoadIcon(NULL, IDI_ERROR); // 窗口图标句柄
wndcls.hInstance = hInstance; // 包含窗口过程函数的程序实例
wndcls.lpfnWndProc = WinSunProc; // 只想窗口过程函数的指针
wndcls.lpszClassName = "Kleist"; // 窗口类名称
wndcls.lpszMenuName = NULL; // 菜单资源
wndcls.style = CS_HREDRAW | CS_VREDRAW; // 窗口样式
RegisterClass(&amp;wndcls);</p>
<p>// 创建窗口， 定义一个变量用来保存成功创建窗口后返回的句柄
HWND hwnd;
hwnd = CreateWindow( // 窗口创建成功时返回为窗口分配的句柄 失败时返回NULL
"Kleist", // 窗口类名
"Hello World", // 窗口名字
WS_OVERLAPPEDWINDOW, // 窗口样式
0, 0, // 窗口左上角坐标
600, 400, // 窗口宽高
NULL, // 父窗口句柄
NULL, // 窗口菜单句柄
hInstance, // 窗口所属应用程序实例
NULL // WM_CREATE消息附加参数lParam传入的数据指针
);</p>
<p>// 显示及刷新窗口
ShowWindow(hwnd, SW_SHOWNORMAL);
UpdateWindow(hwnd);</p>
<p>// 定义消息结构体
MSG msg;
while (GetMessage( // WM_QUIT消息返回0 错误返回-1
&amp;msg, // 指向消息的结构体
NULL, // 指定接收属于哪一窗口的消息 通常设为NULL，用来接收属于调用线程的所有窗口的窗口消息
0, // 获取消息的最小值 通常为0
0)) // 获取消息的最大值 都设为0表示接收所有消息
{
TranslateMessage(&amp;msg); // 将虚拟消息转换为字符消息 投递到调用线程的消息队列中 下次调用GetMessage时被取出
DispatchMessage(&amp;msg); // 将消息传递给操作系统 由操作系统调用窗口过程函数对消息进行处理
}
return msg.wParam;
}</p>
<p>// 窗口过程函数
LRESULT CALLBACK WinSunProc(
HWND hwnd, // 窗口句柄
UINT uMsg, // 消息代码
WPARAM wParam, // 附加参数
LPARAM lParam
)
{
switch(uMsg)
{
case WM_CHAR:
char szChar[20];
sprintf(szChar, "char code is %d", wParam);
MessageBox(hwnd, szChar, "char", 0);
break;</p>
<p>default:
return DefWindowProc(hwnd, uMsg, wParam, lParam);
}</p>
<p _="%" endcodeblock="endcodeblock">return 0;
}</p>
<p>具体也就是WinMain函数作为程序入口，相当于main函数</p>
<p>然后定义窗口类 绑定过程函数，创建窗口实例，显示并刷新窗口实例，建立消息队列。
对着代码看一些参考资料应该就够了。</p> </div>
            <div class="abbr published">Posted <a href='http://smilehacker.com/win32bian-cheng-ru-men.html' title='2013-02-07T21:01:55'>四 07 二月 2013</a></div>
        </article>
        <p class="paginator">
	                                    			<a href="http://smilehacker.com/author/sai/index.html" class="button_accent">&larr;&nbsp;&nbsp;&nbsp;newer</a>
		                     
		                                    <a href="http://smilehacker.com/author/sai/index3.html" class="button_accent" style="position: absolute; right: 0;">continue&nbsp;&nbsp;&nbsp;&rarr;</a>
                	</p>
    </section>

    </body>
</html>